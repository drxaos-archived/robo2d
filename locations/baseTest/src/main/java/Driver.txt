import com.robotech.military.api.*;

import java.awt.geom.Point2D;

public class Driver {
    protected Robot robot;
    protected Chassis chassis;
    protected Radar radar;
    protected Gps gps;

    public Driver(Robot robot) {
        this.robot = robot;
        chassis = robot.getDevice(Chassis.class);
        radar = robot.getDevice(Radar.class);
        gps = robot.getDevice(Gps.class);
    }


    protected void sleep(int ms) {
        try {
            long end = System.currentTimeMillis() + ms;
            while (end > System.currentTimeMillis()) {
                Thread.sleep(end - System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
        }
    }

    public void stop() {
        if (chassis != null) {
            chassis.setLeftAcceleration(0d);
            chassis.setRightAcceleration(0d);
        }
    }

    public boolean move(double x, double y) {
        return move(new Point((float)x, (float)y), 100000);
    }

    public boolean move(Point to, int maxMs) {
        long end = System.currentTimeMillis() + maxMs;
        while (System.currentTimeMillis() < end) {
            int force = 80;
            int rotateForce = 120;
            float width = 2;
            Point current = gps.getPosition();
            double myAngle = gps.getAngle();
            double angleToTarget = angle(current, to);
            double azimuth = differenceAngle(myAngle, angleToTarget);
            double direction = (Math.abs(azimuth) > Math.PI / 2) ? -1 : 1;
            double distance = distance(to, current);
            robot.debug("dist: " + distance);
            if (distance < 1 && Math.abs(azimuth) > 0.2 && Math.abs(azimuth) < Math.PI - 0.2) {
                robot.debug("rotating");
                chassis.setLeftAcceleration(-direction * rotateForce * azimuth);
                chassis.setRightAcceleration(direction * rotateForce * azimuth);
            } else if (distance < 0.2) {
                robot.debug("done");
                stop();
                return true;
            } else {
                double distanceLeft = distance(to, new Point(current.getX() + (float) Math.cos(myAngle + Math.PI / 2) * width, current.getY() + (float) Math.sin(myAngle + Math.PI / 2) * width));
                double distanceRight = distance(to, new Point(current.getX() + (float) Math.cos(myAngle - Math.PI / 2) * width, current.getY() + (float) Math.sin(myAngle - Math.PI / 2) * width));
                double distDiff = distanceLeft - distanceRight;
                double left = direction * (Math.min(1 * force * distance, 100) - rotateForce * distDiff);
                double right = direction * (Math.min(1 * force * distance, 100) + rotateForce * distDiff);
                robot.debug("Left: " + left + ", Right: " + right);
                chassis.setLeftAcceleration(left);
                chassis.setRightAcceleration(right);
            }
            sleep(50);
        }
        stop();
        return false;
    }

    public static double differenceAngle(double theta1, double theta2) {
        double dif = theta2 - theta1;
        while (dif < -Math.PI) dif += 2 * Math.PI;
        while (dif > Math.PI) dif -= 2 * Math.PI;
        return dif;
    }

    public static double angle(Point from, Point to) {
        double dx = from.getX() - to.getX();
        double dy = from.getY() - to.getY();
        return Math.atan2(dy, dx);
    }

    public static double distance(Point from, Point to) {
        return new Point2D.Float(from.getX(), from.getY()).distance(new Point2D.Float(to.getX(), to.getY()));
    }
}

